#docker version
version: "3.8"

#container list
services: 

  frontend:   # 서비스명
    depends_on:  # Specifies the startup order between services : 컨테이너 순서 지정
      - backend
    environment:
      - INTERNAL_BASE_URL=${INTERNAL_BASE_URL}
      - EXTERNAL_BASE_URL=${EXTERNAL_BASE_URL}
    image: blog-frontend:latest # 빌드된 이미지 이름 지정.
    
  backend:
    environment:  #백엔드에서 사용하는 환경변수 주입. 
    # compose.yml이 위치한 디렉토리의 .env -> backend container로 주입.
      - DB_URL=${DB_URL}
      - DB_USERNAME=${DB_USERNAME}
      - DB_PASSWORD=${DB_PASSWORD}
      - JWT_SECRET=${JWT_SECRET}
    depends_on:
      - db
    image: blog-backend:latest # 빌드된 이미지 이름 지정.
 
  db :
    image: postgres:16  # Postgres version - recommended 14+, 16 is latest 
    ports: 
      - "5432:5432"
    environment:
      - POSTGRES_USER=${DB_USERNAME} #POSTGRES_USER는 도커에서 고정된 키워드
      - POSTGRES_PASSWORD=${DB_PASSWORD}
      - POSTGRES_DB=postgres #db연결명 : 환경변수 DB_URL에서 마지막 부분과 동일하게  
    volumes: #호스트 시스템과 컨테이너 사이에 파일이나 폴더 공유. 컨테이너가 종료되어도 데이터 유지, 초기 데이터 주입, 소스코드 공유.
      # - <호스트 경로> : <컨테이너 경로>
      # 호스트 경로 : 실제 컴퓨터의 디렉토리 또는 파일
      # 컨테이너 경로 : 컨테이너 내부의 디렉토리
      - db_data:/var/lib/postgresql/data #DB 영속화
      - ./db:/docker-entrypoint-initdb.d # /docker-entrypoint-initdb.d : 컴포즈 실행 시 호스트 폴더를 스캔해 처리

  # nginx 설정. 
  nginx:
    image: nginx:latest
    ports: # 외부에서는 nginx의 80 포트로만 접근 가능
      - "443:443" # https
    env_file: .env # 환경변수 파일 지정
    volumes: # 호스트와 컨테이너 간의 파일 공유
      - /etc/ssl/certs/fullchain.pem:${SSL_CERT_PATH}:ro # 인증서 파일 공유
      - /etc/ssl/private/privkey.pem:${SSL_KEY_PATH}:ro
    depends_on:
      - frontend
      - backend
    restart: always # nginx 컨테이너가 중지되면 자동으로 재시작
    environment: # nginx에서 사용하는 환경변수 주입
      - FE_HOST=frontend # 프론트엔드 서비스명
      - FE_PORT=3000 # 프론트엔드 포트
      - BE_HOST=backend # 백엔드 서비스명
      - BE_PORT=8089 # 백엔드 포트
      - SERVER_NAME=${SERVER_NAME} # 서버 이름
      - SSL_CERT_PATH=${SSL_CERT_PATH} # SSL 인증서 경로
      - SSL_KEY_PATH=${SSL_KEY_PATH} # SSL 키 경로
volumes:
  db_data : # 이름있는 볼륨 정의  

